{"version":3,"sources":["../../src/config.js","../../src/index.js","../../src/useTypedText.js","App.js","index.js"],"names":["typeSpeed","skipSpace","currentPrompt","donePrompt","cursor","humanElement","UseTypedText","this","JSON","options","min","max","minValue","parseInt","maxValue","Math","rand","global","targetValue","TypedText","useState","value","setValue","typeTo","setTypeTo","tOut","setTOut","clearTimeout","useEffect","unload","newString","speed","setTimeout","useMemo","prompt","useTypedTextHook","onDone","App","focused","setFocus","optionRef","useRef","userText","useTypedText","prettyValue","style","maxWidth","width","margin","display","className","onSubmit","event","preventDefault","stopPropagation","current","autoFocus","id","onFocus","onBlur","defaultValue","ref","justifyContent","alignItems","marginTop","marginBottom","marginLeft","htmlFor","onClick","resetOptions","stringify","color","borderColor","toString","onChange","parse","setOptions","e","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.34b72872.chunk.js","sourcesContent":["export default {\n  // How fast we type;\n  typeSpeed: 60, // ms\n  // Do we time the space string \" \"?\n  skipSpace: true,\n  // The use-prompt to show when typing\n  currentPrompt: \"> \",\n  // The done-prompt to show when typing\n  donePrompt: \"- \",\n  // The cursor to show when typing\n  cursor: \"â–“\",\n  // Random keystroke speed +-50ms\n  humanElement: true,\n};\n","import useTypedTextHook from \"./useTypedText\";\nimport defaultOptions from \"./config\";\n\n\n// export class UseTypedTextOptionError extends Error {\n//   constructor(key, type) { super(`UseTypedText.options[ ${key} ] expected to be of type \"${type}\"`); }\n// }\n\n\n// TypedText definition:\nfunction UseTypedText() {\n  this.defaultOptions = { ...defaultOptions };\n  this.options = { ...defaultOptions };\n}\n\nUseTypedText.prototype.toString = function() {\n  return JSON.stringify(this.options, null, 2);\n}\n\nUseTypedText.prototype.setOptions = function(options = {}) {\n  this.options = { ...this.defaultOptions, ...options };\n}\n\nUseTypedText.prototype.resetOptions = function() {\n  this.options = { ...this.defaultOptions };\n}\n\nUseTypedText.prototype.getDecoration = function(isCurrentlyTyping) {\n  if (isCurrentlyTyping) {\n    return [this.options.currentPrompt, this.options.cursor];\n  }\n  return [this.options.donePrompt, \"\"];\n}\n\nUseTypedText.prototype.getStrokeSpeed = function() {\n  if (!this.options.humanElement) return this.options.typeSpeed;\n  return rand(this.options.typeSpeed - 50, this.options.typeSpeed + 50);\n}\n\n// Your good ol' min max random int method\nfunction rand(min, max) {\n  const minValue = parseInt(min);\n  const maxValue = parseInt(max);\n  return Math.floor(Math.random() * maxValue) + minValue;\n}\n\nglobal.TypedText = global.TypedText || (global.TypedText = new UseTypedText());\n\n// global.TypedText as the default export\nexport default global.TypedText;\n\n// Named export useTypedText - calls useTypedText internal hook\nexport function useTypedText(targetValue, onDone) {\n  return useTypedTextHook(targetValue, onDone, global.TypedText);\n}\n","import { useState, useEffect, useMemo } from \"react\";\n\n\n// Export the hook\nexport default function useTypedText(targetValue = \"\", onDone = () => {}, TypedText = false) {\n  // Track the currently typed value\n  const [value, setValue] = useState(\"\");\n  // Track the value we want to type to\n  const [typeTo, setTypeTo] = useState(targetValue);\n  // Track the timeout id for clean-up on unmount\n  const [tOut, setTOut] = useState();\n\n  // Clean-up the timeout trackers, prevent unmounting errors\n  function unload() {\n    setTOut(clearTimeout(tOut));\n  }\n\n  useEffect(() => {\n    // target value has been unset\n    if (typeTo.length === 0) {\n      // Point the value at an empty string\n      setValue(\"\");\n      // Hot-wire an unload,\n      unload();\n      // Immediately return\n      return;\n    }\n\n    // Not started typing yet...\n    // if (value.length === 0) {\n    // }\n    // Add a letter to the printed substring\n    const newString = typeTo.substring(0, value.length + 1);\n    // Note the type speed for this keystroke\n    const speed = (TypedText && TypedText.getStrokeSpeed()) || 50;\n    // Store the timeout for unloading\n    setTOut(setTimeout(() => {\n      // Print the letter after the timeout\n      setValue(newString);\n      // Unload the async timeout\n      unload();\n    }, speed));\n\n    // Clean up after ourselves\n    return () => { unload(); }\n  }, [typeTo, value]);\n\n  // When we unmount...\n  useEffect(() => {\n    return () => { unload() };\n  }, []);\n\n  // Memoize the prompt/cursor for the return value when the timeout changes\n  // Tiny optimization only noticed when spaces are skipped. But an inch is an inch amirite\n  const [prompt, cursor] = useMemo(() => {\n    if (TypedText && TypedText.getDecoration) return TypedText.getDecoration(typeTo.length && tOut);\n    return [\"\", \"\"];\n  }, [tOut, typeTo]);\n\n  // Return the typed value and the setter for triggering the typing\n  return [\n    `${prompt}${value}${cursor}`,\n    setTypeTo,\n  ];\n}\n","import React, { useRef, useState, } from \"react\";\nimport UseTypedText, { useTypedText } from \"@taystack/use-typed-text\";\n\n\nconst App = () => {\n  const [ focused, setFocus ] = useState(true);\n  const optionRef = useRef();\n  const userText = useRef();\n\n  const [prettyValue, setValue] = useTypedText(\"\");\n\n  function handleTypeIt(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    setValue(\"\");\n    setTimeout(() => {\n      setValue(userText.current.value);\n    }, 0);\n  }\n\n  function handleOptionChange() {\n    try {\n      const options = JSON.parse(optionRef.current.value);\n      UseTypedText.setOptions(options);\n    } catch(e) {\n    }\n  }\n\n  function handleReset() {\n    UseTypedText.resetOptions();\n    optionRef.current.value = JSON.stringify(UseTypedText.options, null, 2);\n  }\n\n  return (\n    <div style={{\n      maxWidth: \"50vw\",\n      width: \"100vw\",\n      margin: \"0 auto\",\n      display: \"block\",\n    }}>\n      <h1>@taystack/use-typed-text</h1>\n      <p>React 16.8 hook. Use the returned setter method to kick-off key-stroke-like UX.</p>\n      <p>Change the text below if you want</p>\n      <form className={`InputWrap ${focused ? \"focused\" : \"\"}`} onSubmit={handleTypeIt} style={{ display: \"flex\" }}>\n        <input\n          autoFocus\n          id=\"user-input\"\n          onFocus={() => setFocus(true)}\n          onBlur={() => setFocus(false)}\n          defaultValue=\"Hit enter to start the typing\"\n          ref={userText}\n        />\n        <button><span>Enter</span></button>\n      </form>\n\n      <div style={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", marginTop: 20, marginBottom: 10, }}>\n        <label style={{ marginLeft: 10, display: \"block\" }} htmlFor=\"options\">Options:</label>\n        <button onClick={handleReset}><span style={{ color: \"#eee\", borderColor: \"#eee\" }}>Reset</span></button>\n      </div>\n      <textarea ref={optionRef} id=\"options\" defaultValue={UseTypedText.toString()} onChange={handleOptionChange} />\n\n      <code style={{ marginTop: 40, display: \"block\", }}>{prettyValue}</code>\n    </div>\n  );\n}\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}